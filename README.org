* ATAC modules
scmodule code [[https://github.com/KellisLab/scmodule][adapted]] for ATAC-seq, multiomics, and peak-gene linking

** Preprocessing
Make sure your data is in an AnnData (H5AD) format with
1. PCA ([[https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.pca.html][scanpy.pp.pca]]), preferably on top of logTF-logIDF ([[https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfTransformer.html][sklearn.feature_extraction.text.TfidfTransformer(sublinear_tf=True)]])
2. QC metrics ([[https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html][scanpy.pp.calculate_qc_metrics]])

so that the modules can be calculated without loading the data matrix into memory.

Using a Gene accessiblity matrix (e.g. as estimated by [[https://www.archrproject.com/bookdown/calculating-gene-scores-in-archr.html][ArchR]]) helps aggregate nearby peaks better than by alone.
This helps even with multiomic ATAC+GEX: use pseudo triple-omic (Peaks, Gene Accessiblity, Gene Expression)
So, for combining these,
1. use TF-IDF (non-logTF) on peak matrix.
2. scale TF-IDF to 10000 counts per cell.
3. scale estimated gene matrix to 10000 counts per cell
4. (optional) scale gene expression matrix to 10000 counts per cell
5. concatenate modalities [[https://anndata.readthedocs.io/en/latest/generated/anndata.concat.html][anndata.concat({"Gene Accessibility": est, "Peaks": peaks, ...}, axis=1, label="feature_types", merge="same")]]
6. log1p
7. [[https://scanpy.readthedocs.io/en/stable/generated/scanpy.pp.calculate_qc_metrics.html][scanpy.pp.calculate_qc_metrics]]
8. PCA

5. use multi-omic workflow
** single-omic workflow (DEPRECATED)
#+BEGIN_SRC python
import atac_module as am
for power in np.linspace(0, 1, 5):
	print("Calculating power:", power)
	am.extract_rep(adata, power=power, margin="log1p_total_counts")
	am.fit_splines(adata)
	am.neighbors(adata, key_added="pow_%.2f" % power)

am.leiden(adata, ["pow_%.2f" % power for power in np.linspace(0, 1, 5)], resolution=1., max_comm_size=2500)
#+END_SRC
** multi-omic workflow (RECOMMENDED)
Note that the n_neighbors parameter can be changed, as n_neighbors is the per-batch number of neighbors
#+BEGIN_SRC python
import atac_module as am
for power in np.linspace(0, 1, 5):
	print("Calculating power:", power)
	am.extract_rep(adata, power=power, margin="log1p_total_counts")
	am.fit_splines(adata, batch="feature_types")
	am.neighbors(adata, key_added="pow_%.2f" % power, n_neighbors=25) ### takes forever but worth it

am.leiden(adata, ["pow_%.2f" % power for power in np.linspace(0, 1, 5)], resolution=1., max_comm_size=2500)
#+END_SRC
** to install
You may need to create a CONDA environment as specified in [[atac_module.yml]].

After dependencies are met, this sequence of commands installs the library.
#+BEGIN_SRC bash
git clone git@github.com:KellisLab/atac_module.git
cd atac_module
python3 setup.py build && pip install .
#+END_SRC
